idée pour la suite : (je sais pas si ça fonctionne comme ça )

// sur la page d'accueil
session_start(); 
$_SESSION['connexion'] = 'visiteur';

//lors de la connexion
$_SESSION['connexion'] = 'jeune';


// au début de la page jeune
if($_SESSION['connexion'] == 'jeune'){ ok } else { nope}




pour la mise à jour de données dans bdd : 

$bdd=exec(UPDATE utilisateur SET nom='$nouveau_nom', ..., WHERE id='$id');


pour récupération id page referent :


<?php
$key='~nu!j_EBK,:XE2e{kQ!bhuQ9j]%SlF]z3L^Qy.Q[Gn?NCe&lt;BBy&gt;^LHv~1P]nq~&amp;;';

    function encode($string, $key) {
        $key = sha1($key); // Génère une clé de chiffrement à partir de la clé fournie en utilisant SHA-1
        $strLen = strlen($string); // Longueur de la chaîne à chiffrer
        $keyLen = strlen($key); // Longueur de la clé de chiffrement
        $j = 0; // Indice pour parcourir la clé
        $hash = ''; // Chaîne chiffrée résultante
        for ($i = 0; $i < $strLen; $i++) {
            $ordStr = ord(substr($string, $i, 1)); // Récupère l'ordre du caractère à l'index $i de la chaîne
            if ($j == $keyLen) { $j = 0; } // Réinitialise l'indice de la clé si on atteint sa fin
            $ordKey = ord(substr($key, $j, 1)); // Récupère l'ordre du caractère correspondant à l'index $j de la clé
            $j++; // Incrémente l'indice de la clé
            $hash .= strrev(base_convert(dechex($ordStr + $ordKey), 16, 36)); // Convertit la somme des deux ordres en base 36 inversée et l'ajoute à la chaîne chiffrée
        }
        return $hash; // Retourne la chaîne chiffrée
    }
    
    function decode($string, $key) {
        $key = sha1($key); // Génère une clé de chiffrement à partir de la clé fournie en utilisant SHA-1
        $strLen = strlen($string); // Longueur de la chaîne chiffrée
        $keyLen = strlen($key); // Longueur de la clé de chiffrement
        $j = 0; // Indice pour parcourir la clé
        $hash = ''; // Chaîne déchiffrée résultante
        for ($i = 0; $i < $strLen; $i += 2) {
            $ordStr = hexdec(base_convert(strrev(substr($string, $i, 2)), 36, 16)); // Convertit la représentation base 36 inversée en décimal
            if ($j == $keyLen) { $j = 0; } // Réinitialise l'indice de la clé si on atteint sa fin
            $ordKey = ord(substr($key, $j, 1)); // Récupère l'ordre du caractère correspondant à l'index $j de la clé
            $j++; // Incrémente l'indice de la clé
            $hash .= chr($ordStr - $ordKey); // Soustrait l'ordre de la clé de l'ordre du caractère et ajoute le caractère déchiffré à la chaîne déchiffrée
        }
        return $hash
    

//au moment de l'envoi
$id=encode($_SESSION['id'],$key);
$num_ref=encode($data['num_ref'],$key);

//envoi lien
http://localhost:8080/page_referent_final?id=$id&num_ref=$num_ref

// quand le référent clique sur le lien décodage identifiant et num_ref

$id=decode($_GET['id'],$key);
$num_ref=decode($_GET['num_ref'],$key);

// vérification demande de référence
$check = $bdd->prepare('SELECT COUNT(*) AS count FROM referent WHERE id = :id_user' AND num_ref= :num_ref);
$check->execute(array($id,$num_ref));
$row = $check->fetch();

if ($row['count'] > 0) {
    $check = $bdd->prepare('SELECT * FROM utilisateur WHERE id = :id_user' AND num_ref= :num_ref);
    $check->execute(array($id, $num_ref));
    $data = $check->fetch();

else {
    echo 'demande de ref introuvable;
    }

?>





